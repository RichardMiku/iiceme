---
sidebar_position: 1
description: MoneyPrinterTurboæ˜¯ä¸€æ¬¾åˆ©ç”¨AIå¤§æ¨¡å‹ï¼Œä¸€éµç”Ÿæˆé«˜è³ªé‡çŸ­è¦–é »çš„å·¥å…·ï¼Œåªéœ€æä¾›ä¸€ä¸ªè§†é¢‘ä¸»é¢˜æˆ–å…³é”®è¯ï¼Œå°±å¯ä»¥å…¨è‡ªåŠ¨ç”Ÿæˆè§†é¢‘æ–‡æ¡ˆã€è§†é¢‘ç´ æã€è§†é¢‘å­—å¹•ã€è§†é¢‘èƒŒæ™¯éŸ³ä¹ï¼Œç„¶ååˆæˆä¸€ä¸ªé«˜æ¸…çš„çŸ­è§†é¢‘ã€‚
---

import ContentCenter from '@site/src/components/ContentCenter';

# MoneyPrinterTurbo

## æ¦‚è§ˆ

+ Github: [MoneyPrinterTurbo](https://github.com/harry0703/MoneyPrinterTurbo)

ä¸€æ¬¾åˆ©ç”¨AIå¤§æ¨¡å‹ï¼Œä¸€éµç”Ÿæˆé«˜è³ªé‡çŸ­è¦–é »çš„å·¥å…·

åªéœ€æä¾›ä¸€ä¸ªè§†é¢‘ ä¸»é¢˜ æˆ– å…³é”®è¯ ï¼Œå°±å¯ä»¥å…¨è‡ªåŠ¨ç”Ÿæˆè§†é¢‘æ–‡æ¡ˆã€è§†é¢‘ç´ æã€è§†é¢‘å­—å¹•ã€è§†é¢‘èƒŒæ™¯éŸ³ä¹ï¼Œç„¶ååˆæˆä¸€ä¸ªé«˜æ¸…çš„çŸ­è§†é¢‘ã€‚

<p align="center">**webuiç•Œé¢**</p>

<ContentCenter>

![webui.jpg](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMJaOH3sqX7-gZaFL60-2g8sALdFmIAAqoLaxvkYxBXLCTOlgqWn6YBAAMCAAN3AAM2BA)

</ContentCenter>

### è§†é¢‘ç¤ºä¾‹ ğŸ“º

> å¦‚è§†é¢‘åŠ è½½ç¼“æ…¢ï¼Œè¯·è€å¿ƒç­‰å¾…

#### æ¨ªå± 16:9

<p align="center">â–¶ï¸ **ã€Šä¸ºä»€ä¹ˆè¦è¿åŠ¨ã€‹** </p>

<ContentCenter>
    <video src="https://img.240021.xyz/api/cfile/BAACAgUAAxkBAAN8aOIEv8D2OJGtIqFg6YoKiLKBmZgAApcYAALdBRBXUQOPkOnehhI2BA" 
    controls width="356" height="200">
        æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå†…åµŒè§†é¢‘ã€‚
    </video>
</ContentCenter>

#### ç«–å± 9:16

<p align="center">â–¶ï¸ **ã€Šå¦‚ä½•å¢åŠ ç”Ÿæ´»çš„ä¹è¶£ã€‹** </p>

<ContentCenter>
    <video src="https://img.240021.xyz/api/cfile/BAACAgUAAxkBAAN7aOIBLpI9YsygwbjNwBbHJCYmoMYAAooYAALdBRBX1iXfxdFw0SU2BA" 
    controls width="200" height="356">
        æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå†…åµŒè§†é¢‘ã€‚
    </video>
</ContentCenter>

## å¿«é€Ÿå¼€å§‹ ğŸš€

### MoneyPrinterTurboå®˜æ–¹å®‰è£…æ•™ç¨‹

:::note å®˜æ–¹ Windows ä¸€é”®å¯åŠ¨åŒ…
ä¸‹è½½ä¸€é”®å¯åŠ¨åŒ…ï¼Œè§£å‹ç›´æ¥ä½¿ç”¨ï¼ˆè·¯å¾„ä¸è¦æœ‰ **ä¸­æ–‡**ã€**ç‰¹æ®Šå­—ç¬¦**ã€**ç©ºæ ¼**ï¼‰

- ç™¾åº¦ç½‘ç›˜ï¼ˆv1.2.6ï¼‰: https://pan.baidu.com/s/1wg0UaIyXpO3SqIpaq790SQ?pwd=sbqx æå–ç : sbqx
- Google Drive (v1.2.6): https://drive.google.com/file/d/1HsbzfT7XunkrCrHw5ncUjFX8XX4zAuUh/view?usp=sharing

ä¸‹è½½åï¼Œå»ºè®®å…ˆ**åŒå‡»æ‰§è¡Œ** `update.bat` æ›´æ–°åˆ°**æœ€æ–°ä»£ç **ï¼Œç„¶ååŒå‡» `start.bat` å¯åŠ¨

å¯åŠ¨åï¼Œä¼šè‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨ï¼ˆå¦‚æœæ‰“å¼€æ˜¯ç©ºç™½ï¼Œå»ºè®®æ¢æˆ **Chrome** æˆ–è€… **Edge** æ‰“å¼€ï¼‰
:::

:::tip æ‰‹åŠ¨éƒ¨ç½²
æ‰‹åŠ¨éƒ¨ç½²è¿‡ç¨‹è¾ƒä¸ºå¤æ‚ï¼Œè¯·å›åˆ°æ¦‚è§ˆï¼Œå¹¶æ‰“å¼€ MoneyPrinterTurbo çš„ GitHub ä»“åº“è¿›è¡ŒæŸ¥çœ‹
:::

:::note å¯åŠ¨æ•™ç¨‹
ä¸‹è½½åï¼Œå»ºè®®å…ˆ**åŒå‡»æ‰§è¡Œ** `update.bat` æ›´æ–°åˆ°**æœ€æ–°ä»£ç **ï¼Œç„¶ååŒå‡» `start.bat` å¯åŠ¨

å¯åŠ¨åï¼Œä¼šè‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨ï¼ˆå¦‚æœæ‰“å¼€æ˜¯ç©ºç™½ï¼Œå»ºè®®æ¢æˆ **Chrome** æˆ–è€… **Edge** æ‰“å¼€ï¼‰
:::

:::info ä½¿ç”¨ GPU åŠ é€Ÿè§†é¢‘ç¼–ç 
å¦‚æœä½ çš„ç”µè„‘æœ‰ GPU å¯ä»¥å‚è€ƒ **[å¦‚ä½•ä¿®æ”¹è§†é¢‘ç¼–ç å™¨](#å¦‚ä½•ä¿®æ”¹è§†é¢‘ç¼–ç å™¨)** éƒ¨åˆ†ï¼Œä½¿ç”¨ GPU åŠ é€Ÿè§†é¢‘ç¼–ç ï¼Œé€Ÿåº¦ä¼šå¿«å¾ˆå¤š
:::

## å¼€å§‹ä½¿ç”¨

### åŸºæœ¬é…ç½®

1. é…ç½®Pexels API Key [ç‚¹å‡»è·å–](https://www.pexels.com/api/)

å¦‚æœä½ å·²å®Œæˆé…ç½®ï¼Œå¯ä»¥è·³è¿‡æ­¤æ­¥éª¤

<details>
  <summary>ç‚¹å‡»å±•å¼€ Pexels API Key æ³¨å†Œæ•™ç¨‹</summary>

<ContentCenter>
  ![Snipaste_2025-10-08_13-40-05.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMQaOX5Q3wNpVC3EaEFmy8Jygtd-ocAAqQLaxt9KjBXKwRx3bRzwGwBAAMCAAN3AAM2BA)
</ContentCenter>

æ³¨å†Œè´¦å·

<ContentCenter>
  ![Snipaste_2025-10-08_13-44-08.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMRaOX6XRJsVCiFRqGMdhcweD5LFQIAAqcLaxt9KjBXlYvTvriJgEQBAAMCAAN5AAM2BA)
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMSaOX6ieNy07-vZeJQb9m1zgzQj7AAAqgLaxt9KjBXEC-10EPYTUwBAAMCAAN4AAM2BA)
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMTaOX7BPipU3Wvz3X5vzlJnnGUtjIAAqkLaxt9KjBXmX6Hm43MK-MBAAMCAAN4AAM2BA)
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMUaOX7jiRKZzJDgOnSAZW4rWin0vkAAqsLaxt9KjBXojqAM1IgPs0BAAMCAAN4AAM2BA)
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMVaOX75YtvylSjf5gAAXlP3WBtPCuUAAKsC2sbfSowVwIbkfiSduEoAQADAgADeAADNgQ)
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMWaOX8UHnjrNnautqXHtHfJSDJHd0AAq0Laxt9KjBXAXow8TqOjckBAAMCAAN4AAM2BA)
</ContentCenter>

å›åˆ° api è·å–é¡µé¢[ç‚¹å‡»è·³è½¬](https://www.pexels.com/api/)

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMXaOX8luraYdTNO8Vo-9PaItfGZd4AAq4Laxt9KjBXzThxkmYjOQYBAAMCAAN3AAM2BA)
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMYaOX-RT3XNmxqO1EgSV8BbEsHs88AAq8Laxt9KjBXu_rkKYKGzOwBAAMCAAN4AAM2BA)
</ContentCenter>

> ç”³è¯·ç†ç”±ï¼š

```text
I plan to use Pexels videos for AI-powered secondary creation. Specifically, I will use them as base footage to train and generate novel video content using generative AI models (such as Style Transfer or GANs). The original videos will be integrated by using their visual data (texture, motion, composition) as input sources for the AI to learn from and transform. The final AI-generated output will be shared across my social media channels and potentially in educational presentations, clearly adhering to Pexels' licensing requirements for attribution and non-commercial/appropriate commercial use.
```

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMZaOX-1nX_iSxrVvb6hiUi0OgIoiAAArALaxt9KjBX3CwoteEyw30BAAMCAAN4AAM2BA)
</ContentCenter>

è·å¾— API Key åï¼Œå›åˆ° MoneyPrinterTurbo çš„é…ç½®é¡µé¢ï¼Œåœ¨ Pexels API Key ç²˜è´´è·å¾—çš„ API Key

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMaaOX_csZCxd5P_pVgMMMjjlztwsEAArILaxt9KjBX2oxYuMLKg2kBAAMCAAN4AAM2BA)
</ContentCenter>

</details>

2. é…ç½® AI API Key

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMbaOYBB5mpZ-1zev-m2c7X_RymAAGfAAK2C2sbfSowV4-2u-BN88vZAQADAgADeAADNgQ)
</ContentCenter>

å¦‚æœæ‚¨ä¸çŸ¥åˆ°ä»€ä¹ˆæ˜¯å¤§æ¨¡å‹ API Keyï¼Œå¯ä»¥è·³è¿‡æ­¤æ­¥éª¤ï¼Œç›´æ¥ä½¿ç”¨ AI Chatï¼Œä¾‹å¦‚ï¼šè±†åŒ…ã€deepseekç­‰

> è¿™é‡Œä¸é…ç½® AIå¤§æ¨¡å‹ ApiKey ç›´æ¥ä½¿ç”¨ **è±†åŒ…** ä½œä¸ºç¤ºä¾‹

### ç”Ÿæˆè§†é¢‘

1. ç¡®å®šè§†é¢‘ä¸»é¢˜

> å¦‚ï¼š***å¦‚ä½•å¢åŠ ç”Ÿæ´»çš„ä¹è¶£***

2. ä¸ **è±†åŒ…** è¿›è¡Œå¯¹è¯ï¼Œç”Ÿæˆã€æ–‡æ¡ˆã€‘å’Œã€å…³é”®è¯ã€‘

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMcaOYCbUT6vR6dpDgAAZ5-7RgsXUzNAAK4C2sbfSowV5JLqDQ8rcP6AQADAgADeQADNgQ)
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMdaOYCpJrXKvYxGJ1BxHTcu3-3H5QAAroLaxt9KjBX23BX7inMwAoBAAMCAAN4AAM2BA)
</ContentCenter>

ç›¸å…³æç¤ºè¯ï¼š

> ç”¨ä¸€æ®µè¯è¯´æ˜å¦‚ä½•å¢åŠ ç”Ÿæ´»çš„ä¹è¶£

>æˆ‘æƒ³å‰ªè¾‘ä¸è¿™ä¸ªä¸»é¢˜æœ‰å…³çš„è§†é¢‘ï¼Œè¯·ä½ å¸®æˆ‘ç”Ÿæˆç›¸å…³è§†é¢‘æ£€ç´¢å…³é”®è¯ï¼Œæ ¼å¼ä¸ºï¼škeywords1,2,3,...ï¼Œkeywordsçš„è¯­è¨€è¯·ä½¿ç”¨è‹±æ–‡

3. åœ¨ MoneyPrinterTurbo ä¸­å®Œæˆç›¸å…³å†…å®¹å¡«å†™

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMfaOYD53SJAlA99R4lRZUS7lJ4UYYAAr8Laxt9KjBXN_TrJSKU6HMBAAMCAAN4AAM2BA)
</ContentCenter>

**å…¶ä»–å†…å®¹æ ¹æ®è‡ªå·±çš„å–œå¥½è¿›è¡Œè®¾ç½®å³å¯**

4. ç‚¹å‡» **ç”Ÿæˆè§†é¢‘** æŒ‰é’®ï¼Œè€å¿ƒç­‰å¾…è§†é¢‘ç”Ÿæˆå®Œæˆ

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMgaOYFBkBwboFwuIrQK1zCdvyy6PoAAsMLaxt9KjBXCj2mdS2nMEcBAAMCAAN3AAM2BA)
</ContentCenter>

### ç”Ÿæˆç»“æœå±•ç¤º

<ContentCenter>
    <video src="https://img.240021.xyz/api/cfile/BAACAgUAAxkBAAN9aOYJa51GOTj0onP_SrZ0hCYCkyYAAuAaAAJC4DFX0hg9aNTsr0U2BA" 
    controls width="200" height="356">
        æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå†…åµŒè§†é¢‘ã€‚
    </video>
</ContentCenter>



## å¦‚ä½•ä¿®æ”¹è§†é¢‘ç¼–ç å™¨

è§†é¢‘é»˜è®¤ä½¿ç”¨ `libx264` ç¼–ç å™¨è¿›è¡Œç¼–ç ï¼Œä½¿ç”¨ CPU è¿›è¡Œç¼–ç ï¼Œé€Ÿåº¦è¾ƒæ…¢ï¼Œå¦‚æœä½ çš„ç”µè„‘æœ‰ NVIDIA GPUï¼Œå¯ä»¥ä¿®æ”¹ä¸º `h264_nvenc` ç¼–ç å™¨ï¼Œä½¿ç”¨ GPU è¿›è¡Œç¼–ç ï¼Œé€Ÿåº¦ä¼šå¿«å¾ˆå¤š

:::danger è­¦å‘Š
è¯·åŠ¡å¿…ä½¿ç”¨ `ffmpeg` å‘½ä»¤æŸ¥çœ‹è®¡ç®—æœºæ”¯æŒçš„ç¼–ç å™¨ï¼Œç¡®ä¿è®¡ç®—æœºæ”¯æŒä½ æ‰€æ›¿æ¢çš„ç¼–ç å™¨ï¼Œå¦åˆ™å¯èƒ½ä¼šå¯¼è‡´ç”Ÿæˆè§†é¢‘å¤±è´¥

> ***`nvenc` ä¸º NVIDIA GPU ç¼–ç å™¨***

> ***æœ¬æ•™ç¨‹åªé’ˆå¯¹ NVIDIA GPU è¿›è¡Œæ¼”ç¤ºï¼Œå…¶ä»–å“ç‰Œ GPU è¯·æŸ¥çœ‹æœ«å°¾çš„è¯´æ˜***
:::

### æŸ¥çœ‹æ”¯æŒçš„ç¼–ç å™¨

1. è§£å‹å®Œæˆåï¼Œæ‰“å¼€ `MoneyPrinterTurbo-Portable-Windows-1.2.6` æ–‡ä»¶å¤¹

`ffmpeg.exe` çš„ä½ç½®å¦‚å›¾æ‰€ç¤ºï¼š

```text title="MoneyPrinterTurbo-Portable-Windows-1.2.6"
MoneyPrinterTurbo-Portable-Windows-1.2.6
  â”œâ”€ Lib
  â”‚   â””â”€ ffmpeg
  â”‚         â””â”€ ffmpeg-7.0-essentials_build
  â”‚                                    â””â”€ ffmpeg.exe
```

2. åœ¨æœ‰ `ffmpeg.exe` çš„æ–‡ä»¶å¤¹å†…ï¼ŒæŒ‰ä½ `Shift` é”®å¹¶**å³é”®å•å‡»ç©ºç™½å¤„**ï¼Œé€‰æ‹© **åœ¨æ­¤å¤„æ‰“å¼€ PowerShell çª—å£**ï¼ˆæˆ– **åœ¨æ­¤å¤„æ‰“å¼€å‘½ä»¤çª—å£**ï¼‰

<details>
 <summary>ç‚¹å‡»å±•å¼€æŸ¥çœ‹ç¤ºä¾‹è¾“å‡ºå†…å®¹</summary>

```powershell title="PowerShell"
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\Miku\Downloads\MoneyPrinterTurbo-Portable-Windows-1.2.6\lib\ffmpeg\ffmpeg-7.0-essentials_build>
```

</details>

3. ç²˜è´´å¹¶æ‰§è¡Œä»¥ä¸‹å‘½ä»¤

```powershell title="PowerShell"
./ffmpeg.exe
```
æ“ä½œå°†ä¼šåˆ—å‡ºå½“å‰ffmpegå¯ä½¿ç”¨çš„ç¼–ç å™¨

<details>
 <summary>ç‚¹å‡»å±•å¼€æŸ¥çœ‹ç¤ºä¾‹è¾“å‡ºå†…å®¹</summary>

```powershell title="PowerShell"
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\Miku\Downloads\MoneyPrinterTurbo-Portable-Windows-1.2.6\lib\ffmpeg\ffmpeg-7.0-essentials_build> ./ffmpeg.exe
ffmpeg version 7.0-essentials_build-www.gyan.dev Copyright (c) 2000-2024 the FFmpeg developers
  built with gcc 13.2.0 (Rev5, Built by MSYS2 project)
  configuration: --enable-gpl --enable-version3 --enable-static --disable-w32threads --disable-autodetect --enable-fontconfig --enable-iconv --enable-gnutls --enable-libxml2 --enable-gmp --enable-bzlib --enable-lzma --enable-zlib --enable-libsrt --enable-libssh --enable-libzmq --enable-avisynth --enable-sdl2 --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-libaom --enable-libopenjpeg --enable-libvpx --enable-mediafoundation --enable-libass --enable-libfreetype --enable-libfribidi --enable-libharfbuzz --enable-libvidstab --enable-libvmaf --enable-libzimg --enable-amf --enable-cuda-llvm --enable-cuvid --enable-dxva2 --enable-d3d11va --enable-d3d12va --enable-ffnvcodec --enable-libvpl --enable-nvdec --enable-nvenc --enable-vaapi --enable-libgme --enable-libopenmpt --enable-libopencore-amrwb --enable-libmp3lame --enable-libtheora --enable-libvo-amrwbenc --enable-libgsm --enable-libopencore-amrnb --enable-libopus --enable-libspeex --enable-libvorbis --enable-librubberband
  libavutil      59.  8.100 / 59.  8.100
  libavcodec     61.  3.100 / 61.  3.100
  libavformat    61.  1.100 / 61.  1.100
  libavdevice    61.  1.100 / 61.  1.100
  libavfilter    10.  1.100 / 10.  1.100
  libswscale      8.  1.100 /  8.  1.100
  libswresample   5.  1.100 /  5.  1.100
  libpostproc    58.  1.100 / 58.  1.100
Universal media converter
usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...

Use -h to get full help or, even better, run 'man ffmpeg'
```

</details>

<p align="center"> **å®Œæ•´çª—å£æˆªå›¾** </p>

<ContentCenter>
![Snipaste_2025-10-05_14-17-06.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMKaOIOQ1MYJIIta9uPOQyycC73TYkAAsgLaxvkYxBXDSmrP86L--IBAAMCAAN5AAM2BA)
</ContentCenter>

4. å¦‚å›¾æ‰€ç¤ºï¼Œè¾“å‡ºå†…å®¹ä¸­æœ‰ `--enable-nvenc` è¡¨ç¤ºæ”¯æŒ NVIDIA GPU åŠ é€Ÿç¼–ç 

### ä¿®æ”¹ç¼–ç å™¨

1. æ‰“å¼€æ–‡ä»¶å¤¹ `MoneyPrinterTurbo-Portable-Windows-1.2.6\MoneyPrinterTurbo\app\services` æ‰¾åˆ° `video.py` æ–‡ä»¶

<ContentCenter>
  ![Snipaste_2025-10-08_13-13-44.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMMaOXzG-uUKasTqAOUxaUyFgO-neEAApsLaxt9KjBXHeSedOImRCQBAAMCAAN4AAM2BA)
</ContentCenter>

2. ä½¿ç”¨æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆæ¨è VSCodeã€Notepad++ï¼‰æ‰“å¼€ `video.py` æ–‡ä»¶

> è¿™é‡Œæ¼”ç¤ºä½¿ç”¨è®°äº‹æœ¬æ‰“å¼€

+ å³é”®å•å‡» `video.py` æ–‡ä»¶ï¼Œé€‰æ‹© **æ‰“å¼€æ–¹å¼** -> **è®°äº‹æœ¬**

+ å¦‚æœè®°äº‹æœ¬æ²¡æœ‰åœ¨åˆ—è¡¨ä¸­ï¼Œé€‰æ‹© **é€‰æ‹©å…¶ä»–åº”ç”¨** -> **æ›´å¤šåº”ç”¨** -> **åœ¨è¿™å°ç”µè„‘ä¸ŠæŸ¥æ‰¾å…¶ä»–åº”ç”¨**ï¼Œç„¶åé€‰æ‹© `C:\Windows\System32\notepad.exe` æ‰“å¼€

<ContentCenter>
  ![åœ–ç‰‡.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMNaOXz_xdYtA6fdg6fWf-zAnoAAV2VAAKcC2sbfSowVxuYMkZI3rIFAQADAgADeAADNgQ)
  ![Snipaste_2025-10-08_13-20-43.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMOaOX0u4mrvjVuGWZe3Ag5TrCK6x4AAp0Laxt9KjBXND5z08PAwvEBAAMCAAN4AAM2BA)
</ContentCenter>

3. å¤åˆ¶ä»¥ä¸‹å†…å®¹æ›¿æ¢ `video.py` æ–‡ä»¶

<details>
 <summary>ç‚¹å‡»å±•å¼€æŸ¥çœ‹ä»£ç </summary>

```python title="video.py"
import glob
import itertools
import os
import random
import gc
import shutil
from typing import List
from loguru import logger
from moviepy import (
    AudioFileClip,
    ColorClip,
    CompositeAudioClip,
    CompositeVideoClip,
    ImageClip,
    TextClip,
    VideoFileClip,
    afx,
    concatenate_videoclips,
)
from moviepy.video.tools.subtitles import SubtitlesClip
from PIL import ImageFont

from app.models import const
from app.models.schema import (
    MaterialInfo,
    VideoAspect,
    VideoConcatMode,
    VideoParams,
    VideoTransitionMode,
)
from app.services.utils import video_effects
from app.utils import utils

class SubClippedVideoClip:
    def __init__(self, file_path, start_time=None, end_time=None, width=None, height=None, duration=None):
        self.file_path = file_path
        self.start_time = start_time
        self.end_time = end_time
        self.width = width
        self.height = height
        if duration is None:
            self.duration = end_time - start_time
        else:
            self.duration = duration

    def __str__(self):
        return f"SubClippedVideoClip(file_path={self.file_path}, start_time={self.start_time}, end_time={self.end_time}, duration={self.duration}, width={self.width}, height={self.height})"


audio_codec = "aac"
# video_codec = "libx264"
video_codec = "h264_nvenc"
fps = 30

def close_clip(clip):
    if clip is None:
        return
        
    try:
        # close main resources
        if hasattr(clip, 'reader') and clip.reader is not None:
            clip.reader.close()
            
        # close audio resources
        if hasattr(clip, 'audio') and clip.audio is not None:
            if hasattr(clip.audio, 'reader') and clip.audio.reader is not None:
                clip.audio.reader.close()
            del clip.audio
            
        # close mask resources
        if hasattr(clip, 'mask') and clip.mask is not None:
            if hasattr(clip.mask, 'reader') and clip.mask.reader is not None:
                clip.mask.reader.close()
            del clip.mask
            
        # handle child clips in composite clips
        if hasattr(clip, 'clips') and clip.clips:
            for child_clip in clip.clips:
                if child_clip is not clip:  # avoid possible circular references
                    close_clip(child_clip)
            
        # clear clip list
        if hasattr(clip, 'clips'):
            clip.clips = []
            
    except Exception as e:
        logger.error(f"failed to close clip: {str(e)}")
    
    del clip
    gc.collect()

def delete_files(files: List[str] | str):
    if isinstance(files, str):
        files = [files]
        
    for file in files:
        try:
            os.remove(file)
        except:
            pass

def get_bgm_file(bgm_type: str = "random", bgm_file: str = ""):
    if not bgm_type:
        return ""

    if bgm_file and os.path.exists(bgm_file):
        return bgm_file

    if bgm_type == "random":
        suffix = "*.mp3"
        song_dir = utils.song_dir()
        files = glob.glob(os.path.join(song_dir, suffix))
        return random.choice(files)

    return ""


def combine_videos(
    combined_video_path: str,
    video_paths: List[str],
    audio_file: str,
    video_aspect: VideoAspect = VideoAspect.portrait,
    video_concat_mode: VideoConcatMode = VideoConcatMode.random,
    video_transition_mode: VideoTransitionMode = None,
    max_clip_duration: int = 5,
    threads: int = 2,
) -> str:
    audio_clip = AudioFileClip(audio_file)
    audio_duration = audio_clip.duration
    logger.info(f"audio duration: {audio_duration} seconds")
    # Required duration of each clip
    req_dur = audio_duration / len(video_paths)
    req_dur = max_clip_duration
    logger.info(f"maximum clip duration: {req_dur} seconds")
    output_dir = os.path.dirname(combined_video_path)

    aspect = VideoAspect(video_aspect)
    video_width, video_height = aspect.to_resolution()

    processed_clips = []
    subclipped_items = []
    video_duration = 0
    for video_path in video_paths:
        clip = VideoFileClip(video_path)
        clip_duration = clip.duration
        clip_w, clip_h = clip.size
        close_clip(clip)
        
        start_time = 0

        while start_time < clip_duration:
            end_time = min(start_time + max_clip_duration, clip_duration)            
            if clip_duration - start_time >= max_clip_duration:
                subclipped_items.append(SubClippedVideoClip(file_path= video_path, start_time=start_time, end_time=end_time, width=clip_w, height=clip_h))
            start_time = end_time    
            if video_concat_mode.value == VideoConcatMode.sequential.value:
                break

    # random subclipped_items order
    if video_concat_mode.value == VideoConcatMode.random.value:
        random.shuffle(subclipped_items)
        
    logger.debug(f"total subclipped items: {len(subclipped_items)}")
    
    # Add downloaded clips over and over until the duration of the audio (max_duration) has been reached
    for i, subclipped_item in enumerate(subclipped_items):
        if video_duration > audio_duration:
            break
        
        logger.debug(f"processing clip {i+1}: {subclipped_item.width}x{subclipped_item.height}, current duration: {video_duration:.2f}s, remaining: {audio_duration - video_duration:.2f}s")
        
        try:
            clip = VideoFileClip(subclipped_item.file_path).subclipped(subclipped_item.start_time, subclipped_item.end_time)
            clip_duration = clip.duration
            # Not all videos are same size, so we need to resize them
            clip_w, clip_h = clip.size
            if clip_w != video_width or clip_h != video_height:
                clip_ratio = clip.w / clip.h
                video_ratio = video_width / video_height
                logger.debug(f"resizing clip, source: {clip_w}x{clip_h}, ratio: {clip_ratio:.2f}, target: {video_width}x{video_height}, ratio: {video_ratio:.2f}")
                
                if clip_ratio == video_ratio:
                    clip = clip.resized(new_size=(video_width, video_height))
                else:
                    if clip_ratio > video_ratio:
                        scale_factor = video_width / clip_w
                    else:
                        scale_factor = video_height / clip_h

                    new_width = int(clip_w * scale_factor)
                    new_height = int(clip_h * scale_factor)

                    background = ColorClip(size=(video_width, video_height), color=(0, 0, 0)).with_duration(clip_duration)
                    clip_resized = clip.resized(new_size=(new_width, new_height)).with_position("center")
                    clip = CompositeVideoClip([background, clip_resized])
                    
                    close_clip(clip_resized)
                    close_clip(background)
                    
            shuffle_side = random.choice(["left", "right", "top", "bottom"])
            if video_transition_mode.value == VideoTransitionMode.none.value:
                clip = clip
            elif video_transition_mode.value == VideoTransitionMode.fade_in.value:
                clip = video_effects.fadein_transition(clip, 1)
            elif video_transition_mode.value == VideoTransitionMode.fade_out.value:
                clip = video_effects.fadeout_transition(clip, 1)
            elif video_transition_mode.value == VideoTransitionMode.slide_in.value:
                clip = video_effects.slidein_transition(clip, 1, shuffle_side)
            elif video_transition_mode.value == VideoTransitionMode.slide_out.value:
                clip = video_effects.slideout_transition(clip, 1, shuffle_side)
            elif video_transition_mode.value == VideoTransitionMode.shuffle.value:
                transition_funcs = [
                    lambda c: video_effects.fadein_transition(c, 1),
                    lambda c: video_effects.fadeout_transition(c, 1),
                    lambda c: video_effects.slidein_transition(c, 1, shuffle_side),
                    lambda c: video_effects.slideout_transition(c, 1, shuffle_side),
                ]
                shuffle_transition = random.choice(transition_funcs)
                clip = shuffle_transition(clip)

            if clip.duration > max_clip_duration:
                clip = clip.subclipped(0, max_clip_duration)
                
            # wirte clip to temp file
            clip_file = f"{output_dir}/temp-clip-{i+1}.mp4"
            clip.write_videofile(clip_file, logger=None, fps=fps, codec=video_codec)
            
            close_clip(clip)
        
            processed_clips.append(SubClippedVideoClip(file_path=clip_file, duration=clip.duration, width=clip_w, height=clip_h))
            video_duration += clip.duration
            
        except Exception as e:
            logger.error(f"failed to process clip: {str(e)}")
    
    # loop processed clips until the video duration matches or exceeds the audio duration.
    if video_duration < audio_duration:
        logger.warning(f"video duration ({video_duration:.2f}s) is shorter than audio duration ({audio_duration:.2f}s), looping clips to match audio length.")
        base_clips = processed_clips.copy()
        for clip in itertools.cycle(base_clips):
            if video_duration >= audio_duration:
                break
            processed_clips.append(clip)
            video_duration += clip.duration
        logger.info(f"video duration: {video_duration:.2f}s, audio duration: {audio_duration:.2f}s, looped {len(processed_clips)-len(base_clips)} clips")
     
    # merge video clips progressively, avoid loading all videos at once to avoid memory overflow
    logger.info("starting clip merging process")
    if not processed_clips:
        logger.warning("no clips available for merging")
        return combined_video_path
    
    # if there is only one clip, use it directly
    if len(processed_clips) == 1:
        logger.info("using single clip directly")
        shutil.copy(processed_clips[0].file_path, combined_video_path)
        delete_files(processed_clips)
        logger.info("video combining completed")
        return combined_video_path
    
    # create initial video file as base
    base_clip_path = processed_clips[0].file_path
    temp_merged_video = f"{output_dir}/temp-merged-video.mp4"
    temp_merged_next = f"{output_dir}/temp-merged-next.mp4"
    
    # copy first clip as initial merged video
    shutil.copy(base_clip_path, temp_merged_video)
    
    # merge remaining video clips one by one
    for i, clip in enumerate(processed_clips[1:], 1):
        logger.info(f"merging clip {i}/{len(processed_clips)-1}, duration: {clip.duration:.2f}s")
        
        try:
            # load current base video and next clip to merge
            base_clip = VideoFileClip(temp_merged_video)
            next_clip = VideoFileClip(clip.file_path)
            
            # merge these two clips
            merged_clip = concatenate_videoclips([base_clip, next_clip])

            # save merged result to temp file
            merged_clip.write_videofile(
                filename=temp_merged_next,
                threads=threads,
                logger=None,
                temp_audiofile_path=output_dir,
                audio_codec=audio_codec,
                fps=fps,
                codec=video_codec,
            )
            close_clip(base_clip)
            close_clip(next_clip)
            close_clip(merged_clip)
            
            # replace base file with new merged file
            delete_files(temp_merged_video)
            os.rename(temp_merged_next, temp_merged_video)
            
        except Exception as e:
            logger.error(f"failed to merge clip: {str(e)}")
            continue
    
    # after merging, rename final result to target file name
    os.rename(temp_merged_video, combined_video_path)
    
    # clean temp files
    clip_files = [clip.file_path for clip in processed_clips]
    delete_files(clip_files)
            
    logger.info("video combining completed")
    return combined_video_path


def wrap_text(text, max_width, font="Arial", fontsize=60):
    # Create ImageFont
    font = ImageFont.truetype(font, fontsize)

    def get_text_size(inner_text):
        inner_text = inner_text.strip()
        left, top, right, bottom = font.getbbox(inner_text)
        return right - left, bottom - top

    width, height = get_text_size(text)
    if width <= max_width:
        return text, height

    processed = True

    _wrapped_lines_ = []
    words = text.split(" ")
    _txt_ = ""
    for word in words:
        _before = _txt_
        _txt_ += f"{word} "
        _width, _height = get_text_size(_txt_)
        if _width <= max_width:
            continue
        else:
            if _txt_.strip() == word.strip():
                processed = False
                break
            _wrapped_lines_.append(_before)
            _txt_ = f"{word} "
    _wrapped_lines_.append(_txt_)
    if processed:
        _wrapped_lines_ = [line.strip() for line in _wrapped_lines_]
        result = "\n".join(_wrapped_lines_).strip()
        height = len(_wrapped_lines_) * height
        return result, height

    _wrapped_lines_ = []
    chars = list(text)
    _txt_ = ""
    for word in chars:
        _txt_ += word
        _width, _height = get_text_size(_txt_)
        if _width <= max_width:
            continue
        else:
            _wrapped_lines_.append(_txt_)
            _txt_ = ""
    _wrapped_lines_.append(_txt_)
    result = "\n".join(_wrapped_lines_).strip()
    height = len(_wrapped_lines_) * height
    return result, height


def generate_video(
    video_path: str,
    audio_path: str,
    subtitle_path: str,
    output_file: str,
    params: VideoParams,
):
    aspect = VideoAspect(params.video_aspect)
    video_width, video_height = aspect.to_resolution()

    logger.info(f"generating video: {video_width} x {video_height}")
    logger.info(f"  â‘  video: {video_path}")
    logger.info(f"  â‘¡ audio: {audio_path}")
    logger.info(f"  â‘¢ subtitle: {subtitle_path}")
    logger.info(f"  â‘£ output: {output_file}")

    # https://github.com/harry0703/MoneyPrinterTurbo/issues/217
    # PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'final-1.mp4.tempTEMP_MPY_wvf_snd.mp3'
    # write into the same directory as the output file
    output_dir = os.path.dirname(output_file)

    font_path = ""
    if params.subtitle_enabled:
        if not params.font_name:
            params.font_name = "STHeitiMedium.ttc"
        font_path = os.path.join(utils.font_dir(), params.font_name)
        if os.name == "nt":
            font_path = font_path.replace("\\", "/")

        logger.info(f"  â‘¤ font: {font_path}")

    def create_text_clip(subtitle_item):
        params.font_size = int(params.font_size)
        params.stroke_width = int(params.stroke_width)
        phrase = subtitle_item[1]
        max_width = video_width * 0.9
        wrapped_txt, txt_height = wrap_text(
            phrase, max_width=max_width, font=font_path, fontsize=params.font_size
        )
        interline = int(params.font_size * 0.25)
        size=(int(max_width), int(txt_height + params.font_size * 0.25 + (interline * (wrapped_txt.count("\n") + 1))))

        _clip = TextClip(
            text=wrapped_txt,
            font=font_path,
            font_size=params.font_size,
            color=params.text_fore_color,
            bg_color=params.text_background_color,
            stroke_color=params.stroke_color,
            stroke_width=params.stroke_width,
            # interline=interline,
            # size=size,
        )
        duration = subtitle_item[0][1] - subtitle_item[0][0]
        _clip = _clip.with_start(subtitle_item[0][0])
        _clip = _clip.with_end(subtitle_item[0][1])
        _clip = _clip.with_duration(duration)
        if params.subtitle_position == "bottom":
            _clip = _clip.with_position(("center", video_height * 0.95 - _clip.h))
        elif params.subtitle_position == "top":
            _clip = _clip.with_position(("center", video_height * 0.05))
        elif params.subtitle_position == "custom":
            # Ensure the subtitle is fully within the screen bounds
            margin = 10  # Additional margin, in pixels
            max_y = video_height - _clip.h - margin
            min_y = margin
            custom_y = (video_height - _clip.h) * (params.custom_position / 100)
            custom_y = max(
                min_y, min(custom_y, max_y)
            )  # Constrain the y value within the valid range
            _clip = _clip.with_position(("center", custom_y))
        else:  # center
            _clip = _clip.with_position(("center", "center"))
        return _clip

    video_clip = VideoFileClip(video_path).without_audio()
    audio_clip = AudioFileClip(audio_path).with_effects(
        [afx.MultiplyVolume(params.voice_volume)]
    )

    def make_textclip(text):
        return TextClip(
            text=text,
            font=font_path,
            font_size=params.font_size,
        )

    if subtitle_path and os.path.exists(subtitle_path):
        sub = SubtitlesClip(
            subtitles=subtitle_path, encoding="utf-8", make_textclip=make_textclip
        )
        text_clips = []
        for item in sub.subtitles:
            clip = create_text_clip(subtitle_item=item)
            text_clips.append(clip)
        video_clip = CompositeVideoClip([video_clip, *text_clips])

    bgm_file = get_bgm_file(bgm_type=params.bgm_type, bgm_file=params.bgm_file)
    if bgm_file:
        try:
            bgm_clip = AudioFileClip(bgm_file).with_effects(
                [
                    afx.MultiplyVolume(params.bgm_volume),
                    afx.AudioFadeOut(3),
                    afx.AudioLoop(duration=video_clip.duration),
                ]
            )
            audio_clip = CompositeAudioClip([audio_clip, bgm_clip])
        except Exception as e:
            logger.error(f"failed to add bgm: {str(e)}")

    video_clip = video_clip.with_audio(audio_clip)
    video_clip.write_videofile(
        output_file,
        audio_codec=audio_codec,
        temp_audiofile_path=output_dir,
        threads=params.n_threads or 2,
        logger=None,
        fps=fps,
        codec=video_codec,
    )
    video_clip.close()
    del video_clip


def preprocess_video(materials: List[MaterialInfo], clip_duration=4):
    for material in materials:
        if not material.url:
            continue

        ext = utils.parse_extension(material.url)
        try:
            clip = VideoFileClip(material.url)
        except Exception:
            clip = ImageClip(material.url)

        width = clip.size[0]
        height = clip.size[1]
        if width < 480 or height < 480:
            logger.warning(f"low resolution material: {width}x{height}, minimum 480x480 required")
            continue

        if ext in const.FILE_TYPE_IMAGES:
            logger.info(f"processing image: {material.url}")
            # Create an image clip and set its duration to 3 seconds
            clip = (
                ImageClip(material.url)
                .with_duration(clip_duration)
                .with_position("center")
            )
            # Apply a zoom effect using the resize method.
            # A lambda function is used to make the zoom effect dynamic over time.
            # The zoom effect starts from the original size and gradually scales up to 120%.
            # t represents the current time, and clip.duration is the total duration of the clip (3 seconds).
            # Note: 1 represents 100% size, so 1.2 represents 120% size.
            zoom_clip = clip.resized(
                lambda t: 1 + (clip_duration * 0.03) * (t / clip.duration)
            )

            # Optionally, create a composite video clip containing the zoomed clip.
            # This is useful when you want to add other elements to the video.
            final_clip = CompositeVideoClip([zoom_clip])

            # Output the video to a file.
            video_file = f"{material.url}.mp4"
            final_clip.write_videofile(video_file, fps=30, logger=None, codec=video_codec)
            close_clip(clip)
            material.url = video_file
            logger.success(f"image processed: {video_file}")
    return materials
```

</details>

<ContentCenter>
  ![Snipaste_2025-10-08_13-25-15.png](https://img.240021.xyz/api/cfile/AgACAgUAAyEGAAS0A577AAMPaOX1zxWhCmqdIJrWF-m3GbSmVMIAAqALaxt9KjBXDciF8eRwbREBAAMCAAN5AAM2BA)
</ContentCenter>


:::tip æç¤º
è‡³æ­¤ï¼Œè§†é¢‘ç¼–ç å™¨å·²ç»ä¿®æ”¹å®Œæˆï¼Œå¯ä»¥ä½¿ç”¨NVIDIA GPUåŠ é€Ÿç”Ÿæˆè§†é¢‘äº†
:::

### å…¶ä»–å“ç‰Œ GPU ä¿®æ”¹è¯´æ˜

åœ¨æ›¿æ¢å®Œæˆçš„ `video.py` ä¸­æ‰¾åˆ°ä»¥ä¸‹å†…å®¹ï¼š

```python
video_codec = "h264_nvenc"
```

å°† `h264_nvenc` æ›¿æ¢ä¸ºå¯¹åº”å“ç‰Œ GPU çš„ç¼–ç å™¨åç§°å³å¯ï¼ŒæŸ¥è¯¢æ–¹æ³•è¯·å›é¡¾ **[æŸ¥çœ‹æ”¯æŒçš„ç¼–ç å™¨](#æŸ¥çœ‹æ”¯æŒçš„ç¼–ç å™¨)** éƒ¨åˆ†

